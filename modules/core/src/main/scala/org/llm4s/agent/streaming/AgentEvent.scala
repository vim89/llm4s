package org.llm4s.agent.streaming

import org.llm4s.agent.AgentState
import org.llm4s.error.LLMError

import java.time.Instant

/**
 * Events emitted during streaming agent execution.
 *
 * AgentEvent provides fine-grained visibility into agent execution,
 * enabling real-time UIs, progress tracking, and debugging.
 *
 * Event categories:
 * - Text events: Token-level streaming during LLM generation
 * - Tool events: Tool invocation lifecycle
 * - Agent lifecycle: Start, step, complete, fail
 * - Handoff events: Agent-to-agent delegation
 *
 * @example
 * {{{
 * agent.runWithEvents(
 *   query = "What's the weather?",
 *   tools = weatherTools,
 *   onEvent = {
 *     case TextDelta(delta, _) => print(delta)
 *     case ToolCallStarted(_, name, _, _) => println(s"[Calling $name]")
 *     case AgentCompleted(state, _) => println("Done!")
 *     case _ => // ignore
 *   }
 * )
 * }}}
 */
sealed trait AgentEvent {

  /**
   * When this event occurred.
   */
  def timestamp: Instant
}

object AgentEvent {

  // ============================================================
  // Text Generation Events
  // ============================================================

  /**
   * A chunk of text was generated by the LLM.
   *
   * These events are emitted in real-time during streaming generation,
   * allowing incremental display to users.
   *
   * @param delta The text chunk (may be partial words)
   * @param timestamp When the chunk was received
   */
  final case class TextDelta(
    delta: String,
    timestamp: Instant
  ) extends AgentEvent

  /**
   * Text generation for the current step completed.
   *
   * @param fullText The complete generated text for this step
   * @param timestamp When generation completed
   */
  final case class TextComplete(
    fullText: String,
    timestamp: Instant
  ) extends AgentEvent

  // ============================================================
  // Tool Execution Events
  // ============================================================

  /**
   * A tool call was requested by the LLM.
   *
   * Emitted when the LLM decides to invoke a tool. The tool
   * has not yet been executed at this point.
   *
   * @param toolCallId Unique identifier for this tool call
   * @param toolName Name of the tool being invoked
   * @param arguments JSON string of arguments passed to the tool
   * @param timestamp When the tool call was requested
   */
  final case class ToolCallStarted(
    toolCallId: String,
    toolName: String,
    arguments: String,
    timestamp: Instant
  ) extends AgentEvent

  /**
   * A tool call completed execution.
   *
   * @param toolCallId Unique identifier matching the start event
   * @param toolName Name of the tool that was invoked
   * @param result The result returned by the tool (as string)
   * @param success Whether the tool executed successfully
   * @param durationMs Execution time in milliseconds
   * @param timestamp When the tool completed
   */
  final case class ToolCallCompleted(
    toolCallId: String,
    toolName: String,
    result: String,
    success: Boolean,
    durationMs: Long,
    timestamp: Instant
  ) extends AgentEvent

  /**
   * A tool call failed during execution.
   *
   * @param toolCallId Unique identifier matching the start event
   * @param toolName Name of the tool that failed
   * @param error Description of the failure
   * @param timestamp When the failure occurred
   */
  final case class ToolCallFailed(
    toolCallId: String,
    toolName: String,
    error: String,
    timestamp: Instant
  ) extends AgentEvent

  // ============================================================
  // Agent Lifecycle Events
  // ============================================================

  /**
   * Agent execution started.
   *
   * @param query The user's query
   * @param toolCount Number of tools available
   * @param timestamp When execution started
   */
  final case class AgentStarted(
    query: String,
    toolCount: Int,
    timestamp: Instant
  ) extends AgentEvent

  /**
   * A new execution step started.
   *
   * An agent may take multiple steps when tools are involved:
   * Step 0: Initial LLM call
   * Step 1: Process tool results
   * Step N: Continue until complete
   *
   * @param stepNumber Zero-based step index
   * @param timestamp When the step started
   */
  final case class StepStarted(
    stepNumber: Int,
    timestamp: Instant
  ) extends AgentEvent

  /**
   * An execution step completed.
   *
   * @param stepNumber Zero-based step index
   * @param hasToolCalls Whether this step produced tool calls
   * @param timestamp When the step completed
   */
  final case class StepCompleted(
    stepNumber: Int,
    hasToolCalls: Boolean,
    timestamp: Instant
  ) extends AgentEvent

  /**
   * Agent execution completed successfully.
   *
   * @param finalState The final agent state
   * @param totalSteps Total number of steps taken
   * @param durationMs Total execution time in milliseconds
   * @param timestamp When execution completed
   */
  final case class AgentCompleted(
    finalState: AgentState,
    totalSteps: Int,
    durationMs: Long,
    timestamp: Instant
  ) extends AgentEvent

  /**
   * Agent execution failed.
   *
   * @param error The error that caused failure
   * @param stepNumber Step where failure occurred (if known)
   * @param timestamp When failure occurred
   */
  final case class AgentFailed(
    error: LLMError,
    stepNumber: Option[Int],
    timestamp: Instant
  ) extends AgentEvent

  // ============================================================
  // Handoff Events
  // ============================================================

  /**
   * Agent is handing off to another agent.
   *
   * @param targetAgentName Name/description of the target agent
   * @param reason Reason for the handoff (if provided)
   * @param preserveContext Whether context is being transferred
   * @param timestamp When handoff was initiated
   */
  final case class HandoffStarted(
    targetAgentName: String,
    reason: Option[String],
    preserveContext: Boolean,
    timestamp: Instant
  ) extends AgentEvent

  /**
   * Handoff completed - control returned from target agent.
   *
   * @param targetAgentName Name of the agent that handled the request
   * @param success Whether the target agent succeeded
   * @param timestamp When handoff completed
   */
  final case class HandoffCompleted(
    targetAgentName: String,
    success: Boolean,
    timestamp: Instant
  ) extends AgentEvent

  // ============================================================
  // Guardrail Events
  // ============================================================

  /**
   * Input guardrail validation started.
   *
   * @param guardrailName Name of the guardrail
   * @param timestamp When validation started
   */
  final case class InputGuardrailStarted(
    guardrailName: String,
    timestamp: Instant
  ) extends AgentEvent

  /**
   * Input guardrail validation completed.
   *
   * @param guardrailName Name of the guardrail
   * @param passed Whether validation passed
   * @param timestamp When validation completed
   */
  final case class InputGuardrailCompleted(
    guardrailName: String,
    passed: Boolean,
    timestamp: Instant
  ) extends AgentEvent

  /**
   * Output guardrail validation started.
   *
   * @param guardrailName Name of the guardrail
   * @param timestamp When validation started
   */
  final case class OutputGuardrailStarted(
    guardrailName: String,
    timestamp: Instant
  ) extends AgentEvent

  /**
   * Output guardrail validation completed.
   *
   * @param guardrailName Name of the guardrail
   * @param passed Whether validation passed
   * @param timestamp When validation completed
   */
  final case class OutputGuardrailCompleted(
    guardrailName: String,
    passed: Boolean,
    timestamp: Instant
  ) extends AgentEvent

  // ============================================================
  // Factory Methods
  // ============================================================

  /**
   * Create a TextDelta event with current timestamp.
   */
  def textDelta(delta: String): TextDelta =
    TextDelta(delta, Instant.now())

  /**
   * Create a TextComplete event with current timestamp.
   */
  def textComplete(fullText: String): TextComplete =
    TextComplete(fullText, Instant.now())

  /**
   * Create a ToolCallStarted event with current timestamp.
   */
  def toolStarted(toolCallId: String, toolName: String, arguments: String): ToolCallStarted =
    ToolCallStarted(toolCallId, toolName, arguments, Instant.now())

  /**
   * Create a ToolCallCompleted event with current timestamp.
   */
  def toolCompleted(
    toolCallId: String,
    toolName: String,
    result: String,
    success: Boolean,
    durationMs: Long
  ): ToolCallCompleted =
    ToolCallCompleted(toolCallId, toolName, result, success, durationMs, Instant.now())

  /**
   * Create an AgentStarted event with current timestamp.
   */
  def agentStarted(query: String, toolCount: Int): AgentStarted =
    AgentStarted(query, toolCount, Instant.now())

  /**
   * Create a StepStarted event with current timestamp.
   */
  def stepStarted(stepNumber: Int): StepStarted =
    StepStarted(stepNumber, Instant.now())

  /**
   * Create a StepCompleted event with current timestamp.
   */
  def stepCompleted(stepNumber: Int, hasToolCalls: Boolean): StepCompleted =
    StepCompleted(stepNumber, hasToolCalls, Instant.now())

  /**
   * Create an AgentCompleted event with current timestamp.
   */
  def agentCompleted(finalState: AgentState, totalSteps: Int, durationMs: Long): AgentCompleted =
    AgentCompleted(finalState, totalSteps, durationMs, Instant.now())

  /**
   * Create an AgentFailed event with current timestamp.
   */
  def agentFailed(error: LLMError, stepNumber: Option[Int] = None): AgentFailed =
    AgentFailed(error, stepNumber, Instant.now())
}
